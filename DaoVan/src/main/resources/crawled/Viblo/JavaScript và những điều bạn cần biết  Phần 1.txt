httpsvibloasiapjavascript-va-nhung-dieu-ban-can-biet-phan--bWrZnWkplxwHana ThoaiDao Follow Published Thursday PM min read JavaScript và những điều bạn cần biết Phần Trending Report JavaScript và những điều bạn cần biết Phần JavaScript là ngôn_ngữ quá_đỗi quen_thuộc với chúng_ta
Bài_viết này mình sẽ không nêu những lý_thuyết ví_dụ như javaScript là gì bla blacái này bạn nào muốn đọc thì có_thể google ra núi ạ mình chỉ viết ngắn_gọn những điều bạn cần phải_biết về JavaScript dựa_theo kinh_nghiệm bản_thân_mình đúc_kết và định_nghĩa theo ngôn_ngữ bình_dân của mình
JavaScript không_chỉ làm_được trên Frontend một_số framework frontend phổ_biến hiện_nay ReactJS VueJS mà còn làm_được cả Backend Nodejs
Bạn thấy JavaScript lợi_hại đúng ko_nào
Dưới đây mình sẽ liệt_kê một số khái_niệm mà người JavaScript cần phải nắm và hiểu được nó
Let's go Đồng_bộ Synchronous và Bất_đồng_bộ Asynchronous là gì Đồng_bộ Synchronous tức_là bạn có công_việc Đánh_răng Ăn_sáng Đi_học
Khi đó bạn làm_việc Đánh_răng hoàn_thành xong bạn mới bạn tay vào làm_việc Ăn_sáng và bạn hoàn_tất việc Ăn_sáng mới bắt_tay vào việc Đi_học Để map với code trong JavaScript thì mình có đoạn code như_sau consolelogĐánh răngconsolelogĂn sángconsolelogĐi học Kết_quả trả về theo đúng thứ_tự Đánh răngĂn sángĐi học Bất_đồng_bộ Asynchronous tức_là bạn có công_việc Đi_chợ Luộc trứng Quét_nhà
Khi bạn làm_xong việc Đi_chợ thì đáng_lẽ bạn sẽ bắt_tay vào việc Nấu_ăn nhưng bạn nhận_thấy việc Nấu_ăn tốn quá_nhiều thời_gian để chờ xong để tiết_kiệm thời_gian thì bạn đi Quét_nhà luôn đỡ bị má quánh nên việc luộc trứng để đó rồi bạn đi thực_hiện công_việc Quét_nhà chứ ko chờ trứng luộc chín mới quét_nhà sau_khi quét_nhà xong bạn luộc trứng lúc_đó đợi trứng chín vắt chân lên coi tivi trong_lúc chờ trứng chín thôi ko sợ má la rồi nè Vậy trong Javascript xảy_ra bất_đồng_bộ khi thực_hiện những tác_vụ tốn nhiều thời_gian như request API đợi API trả về data tốn phút hay khi dùng hàm setTimeout Ajax những tác_vụ này giống như công_việc Luộc trứng mình ví_dụ phía_trên vậy đó consolelogĐi chợfunction cookingEgg alert'Luộc trứng'setTimeoutcookingEgg consolelogQuét nhà Kết_quả trả về như_sau Đi chợQuét nhàLuộc trứng Trong quá_trình bạn làm_việc với JavaScript thì đồng_bộ Synchronous và bất_đồng_bộ Asynchronous sẽ chắc_chắn có xảy_ra Đọc tới đây các bạn sẽ thắc_mắc là nếu trong JavaScript xảy_ra sự_bất_đồng_bộ như_vậy thì khi cần dữ_liệu từ API trả về để lấy data đó xử_lý những việc tiếp_theo thì_sao
Ví_dụ trường_hợp dưới đây thì giải_quyết như_thế_nào ví_dụ lệnh bạn gọi api load list data user var dataList axiospost'apiApiListUsergetList' sau_đó bạn xem dataList consolelog'result' dataList Đoán xem kết_quả trả về là gì nào Lúc_này đợi phản_hồi khi request API vô database để lấy data user trả về cho mình tốn khá lâu và sự_bất_đồng_bộ trong JavaScript xảy_ra nó sẽ ko đợi data trả về mà nó nhảy vô luôn câu lệnh console và dĩ_nhiên nó ko hiểu dataList là gì để log ra rồi_Đây là lúc thằng phổ_biến nhất xử_lý_sự bất_đồng_bộ đưa những câu lệnh đúng thứ_tự theo ý_muốn của mình mà_không nhảy tùm_lum như ví vụ phía_trên trong JavaScript ra_đời Callback
Promise
Asyncawait
Chuyện_gì cũng có cách giải_quyết mà đúng ko nào các bạn
JavaScript thực_thi các tác_vụ như_thế_nào
JavaScript là ngôn_ngữ đơn luồng single thread - tức_là tại thời_điểm chỉ xử_lý việc
Nếu vậy thì khi có tác_vụ tốn thời_gian phút tiếng hay thậm_chí hơn tiếng vì thì phải chờ cho tác_vụ này chạy xong à lúc_đó trình_duyệt sẽ đơ và block luôn_rồi
Vậy tại_sao JavaScript có_thể xảy_ra được sự_bất_đồng_bộ
Vậy cơ_chế hoạt_động của JavaScript như_thế_nào
Mình cũng tìm_hiểu nhé
! JavaScript đã giới_thiệu nó là một ngôn_ngữ đơn luồng cũng có_nghĩa là nó chỉ có một Call Stack và một_lúc chỉ làm một việc thôi
Call Stack là một cấu_trúc dữ_liệu dạng ngăn xếp stack dùng để chứa thông_tin về hoạt_động của chương_trình máy_tính trong_lúc thực_thi nếu các tác_vụ tốn nhiều thời_gian call api ajax setTimeout callback thì các lệnh này sẽ được đưa_vào vùng gọi_là WebAPIs
WebAPIs là nơi chứa cái tác_vụ như call api ajax setTimeout callback mình đã nói trên
Callback Queue Các hàm tác_vụ all api ajax setTimeout callback sẽ được đưa_vào hàng đợi Callback Queue
Event Loop có Nhiệm_vụ của EL là đợi cho Call Stack rỗng rồi sẽ soi Callback Queue xem có gì không nếu_có thì bốc cái đầu_tiên bỏ vào Call Stack để chạy
Xử_lý bất_đồng_bộ trong JavaScript bằng Callback Promise và AsyncAwait Mục_đích của việc xử_lý bất_đồng_bộ mình đã nêu_rõ phần trên bài_viết nếu quên bạn có_thể kéo_lên đọc lại nè Callback Callback là function có đối số_là function - là một hàm sẽ được thực_hiện sau khi một hàm khác đã thực_hiện xong
Ví_dụ sử_dụng callback function doHomeworksubject callback setTimeout function consolelog`Bắt đầu làm_bài_tập subject` callback function alertFinished consolelog'Làm bài_tập xong!' doHomework'Toán' alertFinished Kết_quả trả về theo đúng ý mình muốn rồi Bắt_đầu làm_bài_tập Toán Làm bài_tập xong! Tới đây một vấn_đề xảy_ra là sẽ có lúc function lồng function callback lồng vào nhau quá_nhiều như ví_dụ dưới đây apigetUser'apilistUser' functionerr user if err throw err apigetPostsOfUseruser functionerr posts if err throw err apigetCommentsOfPostsposts functionerr comments vân_vân và mây mây Trường_hợp này gọi_là Callback hell và để giải_quyết vấn_đề này Promise ra_đời
Promise Promise là một cơ_chế trong JavaScript giúp bạn thực_thi các tác_vụ bất_đồng_bộ mà_không rơi vào callback hell hay pyramid of doom
Promise nhận vào hai tham_số Resolve là hàm sẽ được gọi nếu code bất_đồng_bộ trong promise chạy thành_công reject sẽ được gọi nếu code bất_đồng_bộ trong promise chạy thất_bại Để tạo_ra một promise object thì bạn dùng class Promise có sẵn trong trình_duyệt như_sau apigetUser functionusername Hàm apigetUser trả về một promise object return new Promiseresolve reject Gửi AJAX request httpget`usersusername` err result Nếu có lỗi bên_trong callback chúng_ta gọi đến hàm `reject` if err return rejecterr Ngược_lại dùng `resolve` để trả_dữ_liệu về cho `then` resolveresult Như_vậy apigetUser sẽ trả về một promise object
Chúng_ta có_thể truy xuất đến kết_quả trả về bằng phương_thức then Promise cũng cung_cấp phương_thức - then dùng xử_lý sau_khi Promise được thực_hiện thành_công khi resolve được gọi - catch dùng để xử_lý sau_khi Promise có bất_kỳ lỗi nào_đó khi reject được gọi promise then return 'foo' thenresult consolelogresult 'foo' return anotherPromise thenresult consolelogresult `result` sẽ là kết_quả của anotherPromise catcherr Một lỗi chúng_ta hay mắc_phải khi mới làm_quen với Promise đó là tạo_ra kim_tự_tháp promises như_thế này api getUser'pikalong' thenuser api getPostsOfUseruser thenposts api getCommentsOfPostsposts thencomments consolelogcomments catcherr consolelogerr catcherr consolelogerr catcherr consolelogerr Lý_do vì chúng_ta quên_mất tính_chất liên_kết chaining của promise cho_phép bên_trong hàm resolve có_thể trả về một giá_trị đồng_bộ hoặc một promise khác
Do_đó cách giải_quyết là api getUser'pikalong' Trả về một promise thenuser apigetPostsOfUseruser thenposts apigetCommentsOfPostsposts catcherr throw err Ngoài cách đó ra thì cách được dùng phổ_biến và được mọi_người sử_dụng nhiều nhất trong việc xử_lý bất_đồng_bộ là AsyncAwait
AsyncAwait A syncawait là một cơ_chế giúp bạn thực_hiện các thao_tác bất_đồng_bộ một_cách tuần_tự hơn
Asyncawait vẫn sử_dụng Promise ở bên_dưới nhưng code của bạn sẽ trong_sáng và dễ theo_dõi hơn Để sử_dụng bạn phải khai_báo hàm với từ khóa async
Khi đó bên_trong hàm bạn có_thể dùng await async function try const user await apigetUser'pikalong' const posts await apigetPostsOfUseruser const comments await apigetCommentsOfPostsposts consolelogcomments catch err consolelogerr Cần lưu_ý là kết_quả trả về của async function luôn là một Promise async function hello return consoleloghello instanceof Promise true hellothenconsolelog Về bản_chất dùng asyncawait là chạy ngầm Promise
Tuy asyncawait ngắn_gọn hơn dễ_hiểu nhưng có những trường_hợp nên dùng Promise tốt_hơn dùng asyncawait
Ví_dụ như_sau async function getABC let A await getValueA getValueA takes seconds to fisnish let B await getValueB getValueB takes seconds to fisnish let C await getValueC getValueC takes seconds to fisnish return A B C Lúc_này nên dùng Promise vì các hàm getValueA getValueB ko phụ_thuộc vào nhau nhưng gắn await thì tốn thời_gian chờ Dùng Promiseall Việc sử_dụng Promiseall sẽ đảm_bảo chúng_ta có tất_cả kết_quả của các hàm trước_khi thực_thi code sau_đó chúng đều thực_hiện song_song ko chờ_đợi tuần_tự Viết_lại như_sau dùng Promiseall async function getABC Promiseall allows to sned all request at the same time let results await Promiseall [ getValueA getValueB getValueC ] return resultsreduce total value total value Kết_luận Mong rằng bài_viết của mình giúp các bạn hiểu thêm một phần_nào đó về JavaScript
Nếu bài_viết mình có gì sai_sót comment mình phía_dưới để mình có_thể sửa_chữa lỗi_lầm của mình
Cảm_ơn các bạn
Hẹn_gặp lại các bạn trong các bài_viết tiếp_theo nhé
! JavaScript All Rights Reserved Report