Tây_Môn Xuý Tuyết vituan299 Follow 398 17 38 Published about 2 hours ago 4 min read 10 0 0 Godot Shader P4 Hướng_dẫn hiệu_ứng kim_cương khi chuyển màn_hình
Report Hôm_nay mình sẽ huớng dẫn các bạn làm hiệu_ứng này Đầu_tiên các bạn có_thể tạo 1 project mới sau_đó tạo 1 node2D có ColorRect như_sau Thêm shader vào ColorRect nếu_như các bạn không_biết thêm có_thể quay_lại các bài cũ của mình để xem chi_tiết cách tạo shader Sau_khi tạo xong thì sẽ có như_thế này Mình sẽ tạo 1 biến progress để kiểm_soát việc chạy animation cho hiệu_ứng này giá_trị của nó là từ 0 - 1 0 là chưa chạy 0
5 là hiệu_ứng chạy đc 50 rồi 1 là hiệu_ứng chạy hoàn_tất Về cơ_bản thì chúng_ta sẽ code như_sau void fragment if


Chúng_ta sẽ không render pixel này  discard;  mình có_thể điền_vào


để thử biến discard như_sau shader type canvas item;uniform float progress hint range0 1;void fragment  if UV
x + UV
y 2
0 progress  discard;  copy đoạn code trên vào và từ từ kéo biến progress trong phần Shader Param các bạn sẽ thấy như_sau Mình cũng không_có gì để giải_thích quá_nhiều về dòng UV
x + UV
y 2
0 progress Đây là phương_trình nữa mặt_phẳng lớp 10 đã học thôi ax + by + c 0 ax + by + c 1 UV
y cũng từ 0 - 1 nên mình phải nhân 2 vào progress để đảm_bảo khi progress bằng 1 thì nó phải chạy xong hiệu_ứng các bạn có_thể bỏ số 2 để test là sẽ thấy
OK giờ quay_trở_lại vấn_đề chính chúng_ta sẽ điển gì vào


để đạt đc hiệu_ứng mong_muốn Mình sẽ thêm 1 biến để giúp mình kiểm_soát size của hình_thoi Size of each diamond in pixels
uniform float diamondPixelSize = 30f; Chình fragment thành như_sau shader type canvas item;uniform float progress hint range0 1;uniform float diamondPixelSize = 30f;void fragment float xFraction = fractFRAGCOORD
x diamondPixelSize; float yFraction = fractFRAGCOORD
y diamondPixelSize; if xFraction + yFraction progress 2f discard; Lưu_ý Biến FRAGCOORD trả cho chúng_ta toạ_độ của của pixel theo màn_hình vd như 20 pixel 100 pixel Lưu_ý là Biến UV chỉ trả về toạ_độ đã đưọc chuẩn_hoá từ 0 - 1 chứ không trả ra toạ_độ chính_xác của pixel theo màn hình Hàm fract là hàm phân_số nó sẽ trả về_phần phân_số vd fract5
31 = 0
31; fract1
2 = 0
2 Bây_giờ thì hiệu_ứng chạy được như_sau Nhận_xét nó khá giống như func mình test ở lúc_trước nhưng_mà thay_vì phủ chéo lên toàn mình hình_như truớc thì bây_giờ nó chạy trên từng hình_vuông nhỏ có kích_thước được cấu hình tại diamondPixelSize Ưhmmmm như_vậy bây_giờ chúng_ta sẽ app dụng_công_thức của hình_thoi thay_vì dùng công_thức nữa mặt_phẳng như_trên Đại_loại là hình_thoi sẽ có công_thức là X - A + Y - B = R Trong_đó R là bán_kính hình_thoi và A B là tâm của hình_thoi
chúng_ta muốn hình_thoi sẽ nằm ở giữa mối ô_vuông nên chúng là A B = 0
5 0
5 Update code thành như_sau void fragment float xFraction = fractFRAGCOORD
x diamondPixelSize; float yFraction = fractFRAGCOORD
y diamondPixelSize; float xDistance = absxFraction - 0
5; float yDistance = absyFraction - 0
5; if xDistance + yDistance progress 2f discard; Chạy_thử và chúng_ta sẽ thấy Tốt nhưng vẫn còn đơn_điệu quá chúng_ta muốn mở_rộng ra thành các hình_vuông sẽ xuất_hiện từ từ góc trên xuống hoặc từ trái qua phải hoặc từ trên xuống dưới Cái này cũng đơn_giản chúng_ta chỉ cần kết_hợp thêm các phương_trình đường_thẳng phù_hợp vào thì sẽ có đưọc hiệu_ứng như_ý Thay code thành như_sau void fragment float xFraction = fractFRAGCOORD
x diamondPixelSize; float yFraction = fractFRAGCOORD
y diamondPixelSize; float xDistance = absxFraction - 0
5; float yDistance = absyFraction - 0
5; if xDistance + yDistance + UV
x + UV
y progress 4f discard; Nếu muốn cho nó đi từ trái qua phải thì chỉnh thành void fragment float xFraction = fractFRAGCOORD
x diamondPixelSize; float yFraction = fractFRAGCOORD
y diamondPixelSize; float xDistance = absxFraction - 0
5; float yDistance = absyFraction - 0
5; if xDistance + yDistance + UV
x progress 3f discard; Nếu muốn từ trên xuống thì thay thành void fragment float xFraction = fractFRAGCOORD
x diamondPixelSize; float yFraction = fractFRAGCOORD
y diamondPixelSize; float xDistance = absxFraction - 0
5; float yDistance = absyFraction - 0
5; if xDistance + yDistance + UV
y progress 3f discard; Bài của mình tới đây thôi hẹn_gặp các bạn ở lần_khác Shader Godot All Rights Reserved Report